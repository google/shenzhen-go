// The http_server command was automatically generated by Shenzhen Go.
package main

import (
	"bytes"
	"context"
	"fmt"
	"github.com/google/shenzhen-go/dev/parts"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"html/template"
	"image"
	"image/color"
	"image/png"
	"log"
	"math"
	"math/cmplx"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strconv"
	"sync"
	"time"
)

var _ = runtime.Compiler

var (
	cacheHits = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "hits",
			Help:      "Hits to the cache in a Cache node",
		},
		[]string{"node_name", "instance_num"},
	)
	cacheMisses = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "misses",
			Help:      "Misses to the cache in a Cache node",
		},
		[]string{"node_name", "instance_num"},
	)
	cachePuts = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "puts",
			Help:      "Cache node cache insertions",
		},
		[]string{"node_name", "instance_num"},
	)
	cacheEvictions = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "evictions",
			Help:      "Cache node cache evictions",
		},
		[]string{"node_name", "instance_num"},
	)
	cacheSize = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "size",
			Help:      "Size of content in Cache nodes in bytes",
		},
		[]string{"node_name"},
	)
	cacheLimit = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "limit",
			Help:      "Upper limit of content size in Cache nodes in bytes",
		},
		[]string{"node_name"},
	)
	cacheHitsSize = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "hits_size",
			Help:      "Cumulative Cache node cache hits size in bytes",
		},
		[]string{"node_name", "instance_num"},
	)
	cachePutsSize = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "puts_size",
			Help:      "Cumulative Cache node cache insertions size in bytes",
		},
		[]string{"node_name", "instance_num"},
	)
	cacheEvictionsSize = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "cache",
			Name:      "evictions_size",
			Help:      "Cumulative Cache node cache evictions size in bytes",
		},
		[]string{"node_name", "instance_num"},
	)
)

func init() {
	prometheus.MustRegister(
		cacheHits,
		cacheMisses,
		cachePuts,
		cacheSize,
		cacheLimit,
		cacheHitsSize,
		cachePutsSize,
		cacheEvictionsSize,
	)
}

var (
	httpServeMuxRequestsIn = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "httpservemux",
			Name:      "requests_in",
			Help:      "Requests received by HTTPServeMux nodes.",
		},
		[]string{"node_name", "instance_num"},
	)
	httpServeMuxRequestsOut = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "shenzhen_go",
			Subsystem: "httpservemux",
			Name:      "requests_out",
			Help:      "Requests sent out of HTTPServeMux nodes.",
		},
		[]string{"node_name", "instance_num", "output_pin"},
	)
)

func init() {
	prometheus.MustRegister(
		httpServeMuxRequestsIn,
		httpServeMuxRequestsOut,
	)
}

func Cache(get <-chan struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Ctx *parts.HTTPRequest
}, hit chan<- struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Ctx  *parts.HTTPRequest
	Data []byte
}, miss chan<- struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Ctx *parts.HTTPRequest
}, put <-chan struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Data []byte
}) {
	// Cache
	multiplicity := runtime.NumCPU()

	const bytesLimit = 1073741824
	type cacheEntry struct {
		data []byte
		last time.Time
		sync.Mutex
	}
	var mu sync.RWMutex
	totalBytes := uint64(0)
	cache := make(map[struct {
		X, Y int
		Z    uint
	}]*cacheEntry)
	cacheLimit.With(prometheus.Labels{"node_name": "Cache"}).Set(bytesLimit)
	cacheSize := cacheSize.With(prometheus.Labels{"node_name": "Cache"})
	cacheSize.Set(0)

	defer func() {
		close(hit)
		close(miss)
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		instanceNumber := n
		go func() {
			defer multWG.Done()

			labels := prometheus.Labels{
				"node_name":    "Cache",
				"instance_num": strconv.Itoa(instanceNumber),
			}
			cacheHits := cacheHits.With(labels)
			cacheMisses := cacheMisses.With(labels)
			cachePuts := cachePuts.With(labels)
			cacheEvictions := cacheEvictions.With(labels)
			cacheHitsSize := cacheHitsSize.With(labels)
			cachePutsSize := cachePutsSize.With(labels)
			cacheEvictionsSize := cacheEvictionsSize.With(labels)
		handleLoop:
			for {
				select {
				case g, open := <-get:
					if !open {
						break handleLoop
					}
					mu.RLock()
					e, ok := cache[g.Key]
					mu.RUnlock()
					if !ok {
						miss <- g
						cacheMisses.Inc()
						continue
					}
					e.Lock()
					cacheHits.Inc()
					cacheHitsSize.Add(float64(len(e.data)))
					hit <- struct {
						Key struct {
							X, Y int
							Z    uint
						}
						Ctx  *parts.HTTPRequest
						Data []byte
					}{
						Key:  g.Key,
						Ctx:  g.Ctx,
						Data: e.data,
					}
					e.last = time.Now()
					e.Unlock()

				case p, open := <-put:
					if !open {
						put = nil
						continue
					}
					if len(p.Data) > bytesLimit {
						continue
					}

					// TODO: Can improve eviction algorithm - this is simplistic but O(n^2)
					mu.Lock()
					for {
						// Find something to evict if needed.
						var ek struct {
							X, Y int
							Z    uint
						}
						var ee *cacheEntry
						et := time.Now()
						for k, e := range cache {
							e.Lock()
							if e.last.Before(et) {
								ee, et, ek = e, e.last, k
							}
							e.Unlock()
						}
						// Necessary to evict?
						if totalBytes+uint64(len(p.Data)) > bytesLimit {
							// Evict ek.
							if ee == nil {
								break
							}
							ee.Lock()
							size := uint64(len(ee.data))
							ee.Unlock()
							totalBytes -= size
							delete(cache, ek)
							cacheEvictions.Inc()
							cacheEvictionsSize.Add(float64(size))
							continue
						}

						// No - insert now.
						size := uint64(len(p.Data))
						cache[p.Key] = &cacheEntry{
							data: p.Data,
							last: time.Now(),
						}
						totalBytes += size
						cachePuts.Inc()
						cachePutsSize.Add(float64(size))
						cacheSize.Set(float64(totalBytes))
						break
					}
					mu.Unlock()
				}
			}
			if put != nil {
				for range put {
				}
			}

		}()
	}
}

func Duration(in <-chan *parts.HTTPRequest, out chan<- *parts.HTTPRequest) {
	// Duration
	multiplicity := runtime.NumCPU()

	sum := prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: "shenzhen_go",
			Subsystem: "instrument_handler",
			Name:      "Duration",
			Help:      "Durations of requests",
			Buckets:   []float64(nil),
		},
		[]string(nil))
	prometheus.MustRegister(sum)

	defer func() {
		close(out)
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()

			h := promhttp.InstrumentHandlerDuration(sum, parts.HTTPHandler(out))
			for r := range in {
				h.ServeHTTP(r.ResponseWriter, r.Request)
				r.Close()
			}
		}()
	}
}

func Extract_parameters(inputs <-chan *parts.HTTPRequest, outputs chan<- struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Ctx *parts.HTTPRequest
}) {
	// Extract parameters
	multiplicity := runtime.NumCPU()

	defer func() {
		if outputs != nil {
			close(outputs)
		}
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()
			for input := range inputs {
				func() {
					q := input.Request.URL.Query()
					x, e0 := strconv.Atoi(q.Get("x"))
					y, e1 := strconv.Atoi(q.Get("y"))
					z, e2 := strconv.ParseUint(q.Get("z"), 10, 64)
					if e0 != nil || e1 != nil || e2 != nil || z > 50 {
						http.Error(input, "invalid parameter", http.StatusBadRequest)
						input.Close()
						return
					}
					outputs <- struct {
						Key struct {
							X, Y int
							Z    uint
						}
						Ctx *parts.HTTPRequest
					}{
						Key: struct {
							X, Y int
							Z    uint
						}{
							X: x,
							Y: y,
							Z: uint(z),
						},
						Ctx: input,
					}
				}()
			}
		}()
	}
}

func Generate_a_Mandelbrot(inputs <-chan struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Ctx *parts.HTTPRequest
}, outputs chan<- struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Data []byte
}) {
	// Generate a Mandelbrot
	multiplicity := runtime.NumCPU()

	defer func() {
		if outputs != nil {
			close(outputs)
		}
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()
			for input := range inputs {
				func() {
					const tileW = 320
					const depth = 25

					zoom := 1 << input.Key.Z
					offset := complex(float64(input.Key.X), float64(input.Key.Y))

					img := image.NewRGBA(image.Rect(0, 0, tileW, tileW))

					for i := 0; i < tileW; i++ {
						for j := 0; j < tileW; j++ {
							c := complex(float64(i), float64(j))
							c /= tileW
							c += offset
							c *= 2
							c /= complex(float64(zoom), 0)

							z := 0i

							col := color.Black
							for k := 0; k < depth; k++ {
								z = z*z + c

								// Higher escape radius makes it smoother
								if mz := cmplx.Abs(z); mz > 50 {
									sm := float64(k) + 1 - math.Log2(math.Log(mz))
									col = color.Gray16{uint16(sm * 65536 / depth)}
									break
								}
							}
							img.Set(i, j, col)
						}
					}

					b := bytes.NewBuffer(nil)
					png.Encode(b, img)
					// Put into cache
					outputs <- struct {
						Key struct {
							X, Y int
							Z    uint
						}
						Data []byte
					}{
						Key:  input.Key,
						Data: b.Bytes(),
					}

					http.ServeContent(
						input.Ctx.ResponseWriter,
						input.Ctx.Request,
						"mandelbrot.png",
						time.Now(),
						bytes.NewReader(b.Bytes()),
					)
					input.Ctx.Close()

				}()
			}
		}()
	}
}

func HTTP_Server(errors chan<- error, manager <-chan parts.HTTPServerManager, requests chan<- *parts.HTTPRequest) {
	// HTTP Server

	defer func() {
		close(requests)
		if errors != nil {
			close(errors)
		}
	}()

	for mgr := range manager {
		svr := &http.Server{
			Handler: parts.HTTPHandler(requests),
			Addr:    mgr.Addr(),
		}
		done := make(chan struct{})
		go func() {
			if err := svr.ListenAndServe(); err != nil && errors != nil {
				errors <- err
			}
			close(done)
		}()
		if err := svr.Shutdown(mgr.Wait()); err != nil && errors != nil {
			errors <- err
		}
		<-done
	}
}

func Handle_(requests <-chan *parts.HTTPRequest) {
	// Handle /
	multiplicity := runtime.NumCPU()
	tmpl := template.Must(template.New("root").Parse(`<html>
<head>
	<title>Mandelbrot viewer</title>
	<style><!--
		img {
			float: left;
		}
		img.first {
			clear: left;
		}
		img:hover {
			border: thick red;
		}
	--></style>
</head>
<body>
	<img src="/mandelbrot?x={{.X}}&y={{.Y}}&z={{.Z}}" class="first" />
	<img src="/mandelbrot?x={{.X1}}&y={{.Y}}&z={{.Z}}" />
	<img src="/mandelbrot?x={{.X}}&y={{.Y1}}&z={{.Z}}" class="first" />
	<img src="/mandelbrot?x={{.X1}}&y={{.Y1}}&z={{.Z}}" />
</body>
</html>`))

	type params struct {
		X, X1, Y, Y1 int
		Z            uint
	}
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()
			for r := range requests {
				func() {
					defer r.Close()
					p := params{X: -1, X1: 0, Y: -1, Y1: 0, Z: 0}
					q := r.Request.URL.Query()
					if xs := q.Get("x"); xs != "" {
						x, err := strconv.Atoi(xs)
						if err != nil {
							http.Error(r, "invalid x parameter", http.StatusBadRequest)
							return
						}
						p.X, p.X1 = x, x+1
					}
					if ys := q.Get("y"); ys != "" {
						y, err := strconv.Atoi(ys)
						if err != nil {
							http.Error(r, "invalid y parameter", http.StatusBadRequest)
							return
						}
						p.Y, p.Y1 = y, y+1
					}
					if zs := q.Get("z"); zs != "" {
						z, err := strconv.ParseUint(q.Get("z"), 10, 64)
						if err != nil {
							http.Error(r, "invalid z parameter", http.StatusBadRequest)
							return
						}
						p.Z = uint(z)
					}
					if err := tmpl.Execute(r, p); err != nil {
						panic(err)
					}
				}()
			}
		}()
	}
}

func Log_errors(errors <-chan error) {
	// Log errors

	for err := range errors {
		log.Printf("HTTP server: %v", err)
	}
}

func Mandelbrot_duration(in <-chan *parts.HTTPRequest, out chan<- *parts.HTTPRequest) {
	// Mandelbrot duration
	multiplicity := runtime.NumCPU()

	sum := prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: "shenzhen_go",
			Subsystem: "instrument_handler",
			Name:      "Mandelbrot_duration",
			Help:      "Durations of requests",
			Buckets:   []float64(nil),
		},
		[]string(nil))
	prometheus.MustRegister(sum)

	defer func() {
		close(out)
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()

			h := promhttp.InstrumentHandlerDuration(sum, parts.HTTPHandler(out))
			for r := range in {
				h.ServeHTTP(r.ResponseWriter, r.Request)
				r.Close()
			}
		}()
	}
}

func Metrics(requests <-chan *parts.HTTPRequest) {
	// Metrics
	multiplicity := runtime.NumCPU()

	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()
			h := promhttp.Handler()
			for r := range requests {
				h.ServeHTTP(r.ResponseWriter, r.Request)
				r.Close()
			}
		}()
	}
}

func Mux(mandelbrot chan<- *parts.HTTPRequest, metrics chan<- *parts.HTTPRequest, requests <-chan *parts.HTTPRequest, root chan<- *parts.HTTPRequest) {
	// Mux
	multiplicity := runtime.NumCPU()
	mux := http.NewServeMux()
	outLabels := make(map[parts.HTTPHandler]string)
	mux.Handle("/", parts.HTTPHandler(root))
	outLabels[root] = "root"
	mux.Handle("/mandelbrot", parts.HTTPHandler(mandelbrot))
	outLabels[mandelbrot] = "mandelbrot"
	mux.Handle("/metrics", parts.HTTPHandler(metrics))
	outLabels[metrics] = "metrics"

	defer func() {
		close(root)
		close(mandelbrot)
		close(metrics)

	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		instanceNumber := n
		go func() {
			defer multWG.Done()

			labels := prometheus.Labels{
				"node_name":    "Mux",
				"instance_num": strconv.Itoa(instanceNumber),
			}
			reqsIn := httpServeMuxRequestsIn.With(labels)
			reqsOut := httpServeMuxRequestsOut.MustCurryWith(labels)
			for req := range requests {
				reqsIn.Inc()
				// Borrow fix for Go issues #3692 and #5955.
				if req.Request.RequestURI == "*" {
					if req.Request.ProtoAtLeast(1, 1) {
						req.ResponseWriter.Header().Set("Connection", "close")
					}
					req.ResponseWriter.WriteHeader(http.StatusBadRequest)
					req.Close()
					continue
				}
				h, _ := mux.Handler(req.Request)
				hh, ok := h.(parts.HTTPHandler)
				if !ok {
					// ServeMux may return handlers that weren't added in the head.
					h.ServeHTTP(req.ResponseWriter, req.Request)
					req.Close()
					continue
				}
				reqsOut.With(prometheus.Labels{"output_pin": outLabels[hh]}).Inc()
				hh <- req
			}
		}()
	}
}

func Serve_from_cache(inputs <-chan struct {
	Key struct {
		X, Y int
		Z    uint
	}
	Ctx  *parts.HTTPRequest
	Data []byte
}, outputs chan<- interface{}) {
	// Serve from cache
	multiplicity := runtime.NumCPU()

	defer func() {
		if outputs != nil {
			close(outputs)
		}
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()
			for input := range inputs {
				func() {
					http.ServeContent(
						input.Ctx.ResponseWriter,
						input.Ctx.Request,
						"mandelbrot.png",
						time.Now(),
						bytes.NewReader(input.Data),
					)
					input.Ctx.Close()
				}()
			}
		}()
	}
}

func Server_manager(manager chan<- parts.HTTPServerManager) {
	// Server manager

	defer func() {
		close(manager)
	}()
	mgr := parts.NewHTTPServerManager(":8765")
	manager <- mgr

	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt)
	fmt.Println("Press Ctrl-C (or SIGINT) to shut down.")
	<-sig

	timeout := 5 * time.Second
	fmt.Printf("Shutting down within %v...\n", timeout)
	ctx, canc := context.WithTimeout(context.Background(), timeout)
	mgr.Shutdown(ctx)
	go func() {
		time.Sleep(timeout)
		canc()
	}()
}

func main() {

	channel0 := make(chan *parts.HTTPRequest, 0)
	channel1 := make(chan parts.HTTPServerManager, 0)
	channel10 := make(chan struct {
		Key struct {
			X, Y int
			Z    uint
		}
		Data []byte
	}, 0)
	channel11 := make(chan struct {
		Key struct {
			X, Y int
			Z    uint
		}
		Ctx  *parts.HTTPRequest
		Data []byte
	}, 0)
	channel2 := make(chan error, 0)
	channel3 := make(chan *parts.HTTPRequest, 0)
	channel4 := make(chan *parts.HTTPRequest, 0)
	channel5 := make(chan *parts.HTTPRequest, 0)
	channel6 := make(chan *parts.HTTPRequest, 0)
	channel7 := make(chan *parts.HTTPRequest, 0)
	channel8 := make(chan struct {
		Key struct {
			X, Y int
			Z    uint
		}
		Ctx *parts.HTTPRequest
	}, 0)
	channel9 := make(chan struct {
		Key struct {
			X, Y int
			Z    uint
		}
		Ctx *parts.HTTPRequest
	}, 0)

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		Cache(channel8, channel11, channel9, channel10)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Duration(channel4, channel5)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Extract_parameters(channel7, channel8)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Generate_a_Mandelbrot(channel9, channel10)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		HTTP_Server(channel2, channel1, channel0)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Handle_(channel5)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Log_errors(channel2)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Mandelbrot_duration(channel6, channel7)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Metrics(channel3)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Mux(channel6, channel3, channel0, channel4)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Serve_from_cache(channel11, nil)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Server_manager(channel1)
		wg.Done()
	}()

	// Wait for the various goroutines to finish.
	wg.Wait()
}
